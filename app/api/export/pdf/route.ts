import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient, supabaseAdmin } from '@/lib/supabase';
import PDFDocument from 'pdfkit';

export async function POST(request: NextRequest) {
  try {
    // Check authentication
    const response = NextResponse.next();
    const supabase = createRouteHandlerClient(request, response);
    
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { success: false, error: 'Authentication required' },
        { status: 401 }
      );
    }

    const { summaryId } = await request.json();

    if (!summaryId) {
      return NextResponse.json(
        { success: false, error: 'Summary ID is required' },
        { status: 400 }
      );
    }

    // Get summary data
    if (!supabaseAdmin) {
      return NextResponse.json(
        { success: false, error: 'Database not available' },
        { status: 503 }
      );
    }

    const { data: summary, error: summaryError } = await supabaseAdmin
      .from('summaries')
      .select(`
        *,
        file_uploads (
          file_name,
          file_size,
          file_type,
          created_at
        )
      `)
      .eq('id', summaryId)
      .eq('user_id', user.id)
      .single();

    if (summaryError || !summary) {
      return NextResponse.json(
        { success: false, error: 'Summary not found' },
        { status: 404 }
      );
    }

    // Create PDF document
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });

    const chunks: Buffer[] = [];
    
    doc.on('data', (chunk) => {
      chunks.push(chunk);
    });

    // Add header
    doc.fontSize(20)
       .font('Helvetica-Bold')
       .text('Document Summary', { align: 'center' });

    doc.moveDown(1);

    // Add title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .text(summary.title || 'Untitled Summary');

    doc.moveDown(0.5);

    // Add metadata
    doc.fontSize(10)
       .font('Helvetica')
       .fillColor('gray')
       .text(`Created: ${new Date(summary.created_at).toLocaleString()}`)
       .text(`Source: ${summary.source_type || 'Unknown'}`)
       .text(`File: ${summary.file_name || 'N/A'}`);

    if (summary.file_uploads) {
      doc.text(`File Size: ${(summary.file_uploads.file_size / 1024 / 1024).toFixed(2)} MB`)
         .text(`File Type: ${summary.file_uploads.file_type}`);
    }

    doc.moveDown(1);

    // Add separator line
    doc.strokeColor('lightgray')
       .lineWidth(1)
       .moveTo(50, doc.y)
       .lineTo(550, doc.y)
       .stroke();

    doc.moveDown(1);

    // Add content
    doc.fontSize(12)
       .font('Helvetica')
       .fillColor('black')
       .text('Summary Content:', { underline: true });

    doc.moveDown(0.5);

    // Split content into paragraphs and add them
    const content = summary.content || 'No content available';
    const paragraphs = content.split('\n\n');

    paragraphs.forEach((paragraph: string, index: number) => {
      if (paragraph.trim()) {
        doc.text(paragraph.trim(), {
          align: 'justify',
          lineGap: 2
        });
        
        if (index < paragraphs.length - 1) {
          doc.moveDown(0.5);
        }
      }
    });

    // Add metadata section if available
    if (summary.metadata) {
      doc.addPage();
      
      doc.fontSize(16)
         .font('Helvetica-Bold')
         .text('Document Metadata');

      doc.moveDown(1);

      const metadata = summary.metadata as any;
      Object.entries(metadata).forEach(([key, value]) => {
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .text(`${key.charAt(0).toUpperCase() + key.slice(1)}:`, { continued: true })
           .font('Helvetica')
           .text(` ${String(value)}`);
      });
    }

    // Add footer
    const pageCount = doc.bufferedPageRange().count;
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);
      
      doc.fontSize(8)
         .font('Helvetica')
         .fillColor('gray')
         .text(
           `Generated by Slack Summary Scribe - Page ${i + 1} of ${pageCount}`,
           50,
           doc.page.height - 50,
           { align: 'center' }
         );
    }

    // Finalize PDF
    doc.end();

    // Wait for PDF generation to complete
    const buffer = await new Promise<Buffer>((resolve) => {
      doc.on('end', () => {
        resolve(Buffer.concat(chunks));
      });
    });

    // Log export activity
    try {
      if (supabaseAdmin) {
        await supabaseAdmin
        .from('exports')
        .insert({
          user_id: user.id,
          organization_id: summary.organization_id,
          summary_id: summaryId,
          export_type: 'pdf',
          export_status: 'completed'
        });
      }
    } catch (logError) {
      console.error('Failed to log export:', logError);
    }

    // Create notification
    try {
      if (supabaseAdmin) {
        await supabaseAdmin
        .from('notifications')
        .insert({
          user_id: user.id,
          organization_id: summary.organization_id,
          type: 'export_complete',
          title: 'Export Complete',
          message: `Your PDF export for "${summary.title}" is ready!`,
          data: {
            summaryId,
            exportType: 'pdf',
            fileName: `${summary.title || 'summary'}.pdf`
          }
        });
      }
    } catch (notificationError) {
      console.error('Failed to create notification:', notificationError);
    }

    // Return PDF file
    return new NextResponse(buffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${summary.title || 'summary'}.pdf"`,
        'Content-Length': buffer.length.toString()
      }
    });

  } catch (error) {
    console.error('PDF export error:', error);
    
    // Log failed export
    try {
      const { summaryId } = await request.json();
      if (summaryId && supabaseAdmin) {
        await supabaseAdmin
          .from('exports')
          .insert({
            user_id: (await createRouteHandlerClient(request, NextResponse.next()).auth.getUser()).data.user?.id,
            summary_id: summaryId,
            export_type: 'pdf',
            export_status: 'failed',
            error_message: error instanceof Error ? error.message : 'Unknown error'
          });
      }
    } catch (logError) {
      console.error('Failed to log failed export:', logError);
    }

    return NextResponse.json(
      { success: false, error: 'Export failed' },
      { status: 500 }
    );
  }
}
