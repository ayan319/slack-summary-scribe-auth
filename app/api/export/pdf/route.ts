import { NextRequest, NextResponse } from 'next/server';
import PDFDocument from 'pdfkit';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { trackExport, trackNotificationSent } from '@/lib/analytics';

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });

    // Get the current user session
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();

    if (sessionError || !session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const userId = session.user.id;
    const { summaryId } = await request.json();

    if (!summaryId) {
      return NextResponse.json(
        { success: false, error: 'Summary ID is required' },
        { status: 400 }
      );
    }

    // Verify user owns the summary
    const { data: summaryData, error: summaryError } = await supabase
      .from('summaries')
      .select('*')
      .eq('id', summaryId)
      .eq('user_id', userId)
      .single();

    if (summaryError || !summaryData) {
      return NextResponse.json(
        { error: 'Summary not found or access denied' },
        { status: 404 }
      );
    }

    // Use the real summary data from database
    const summary = summaryData;

    // Create PDF document
    const doc = new PDFDocument({
      margin: 50,
      size: 'A4'
    });

    const chunks: Buffer[] = [];
    
    doc.on('data', (chunk) => {
      chunks.push(chunk);
    });

    // Add header
    doc.fontSize(20)
       .font('Helvetica-Bold')
       .text('Document Summary', { align: 'center' });

    doc.moveDown(1);

    // Add title
    doc.fontSize(16)
       .font('Helvetica-Bold')
       .text(summary.title || 'Untitled Summary');

    doc.moveDown(0.5);

    // Add metadata
    doc.fontSize(10)
       .font('Helvetica')
       .fillColor('gray')
       .text(`Created: ${new Date(summary.created_at).toLocaleString()}`)
       .text(`Source: Demo`)
       .text(`File: demo-export.pdf`);

    if (summary.file_uploads && summary.file_uploads.length > 0) {
      const fileInfo = summary.file_uploads[0];
      doc.text(`File Size: ${(fileInfo.file_size / 1024 / 1024).toFixed(2)} MB`)
         .text(`File Type: ${fileInfo.file_type}`);
    }

    doc.moveDown(1);

    // Add separator line
    doc.strokeColor('lightgray')
       .lineWidth(1)
       .moveTo(50, doc.y)
       .lineTo(550, doc.y)
       .stroke();

    doc.moveDown(1);

    // Add content
    doc.fontSize(12)
       .font('Helvetica')
       .fillColor('black')
       .text('Summary Content:', { underline: true });

    doc.moveDown(0.5);

    // Split content into paragraphs and add them
    const content = summary.summary_text || 'No content available';
    const paragraphs = content.split('\n\n');

    paragraphs.forEach((paragraph: string, index: number) => {
      if (paragraph.trim()) {
        doc.text(paragraph.trim(), {
          align: 'justify',
          lineGap: 2
        });
        
        if (index < paragraphs.length - 1) {
          doc.moveDown(0.5);
        }
      }
    });

    // Add metadata section (demo data)
    const demoMetadata = {
      processing_time: '1.25 seconds',
      ai_model: 'deepseek-chat',
      confidence_score: '92%',
      word_count: 450,
      language: 'English'
    };

    doc.addPage();

    doc.fontSize(16)
       .font('Helvetica-Bold')
       .text('Document Metadata');

    doc.moveDown(1);

    Object.entries(demoMetadata).forEach(([key, value]) => {
      doc.fontSize(10)
         .font('Helvetica-Bold')
         .text(`${key.charAt(0).toUpperCase() + key.slice(1)}:`, { continued: true })
         .font('Helvetica')
         .text(` ${String(value)}`);
    });

    // Add footer
    const pageCount = doc.bufferedPageRange().count;
    for (let i = 0; i < pageCount; i++) {
      doc.switchToPage(i);
      
      doc.fontSize(8)
         .font('Helvetica')
         .fillColor('gray')
         .text(
           `Generated by Slack Summary Scribe - Page ${i + 1} of ${pageCount}`,
           50,
           doc.page.height - 50,
           { align: 'center' }
         );
    }

    // Finalize PDF
    doc.end();

    // Wait for PDF generation to complete
    const buffer = await new Promise<Buffer>((resolve) => {
      doc.on('end', () => {
        resolve(Buffer.concat(chunks));
      });
    });

    // Log export activity
    await supabase
      .from('exports')
      .insert({
        user_id: userId,
        file_id: summary.file_id,
        summary_id: summaryId,
        export_type: 'pdf',
        file_name: `${summary.title || 'summary'}.pdf`,
        created_at: new Date().toISOString()
      });

    // Create notification
    await supabase
      .from('notifications')
      .insert({
        user_id: userId,
        type: 'export_completed',
        title: 'PDF Export Ready',
        message: `Your PDF export "${summary.title || 'summary'}.pdf" is ready for download.`,
        data: {
          summaryId: summaryId,
          exportType: 'pdf'
        },
        read: false,
        created_at: new Date().toISOString()
      });

    // Track analytics
    await trackExport(userId, 'pdf', summaryId);
    await trackNotificationSent(userId, 'export_completed', 'in_app');

    // Return PDF file
    return new NextResponse(buffer, {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${summary.title || 'summary'}.pdf"`,
        'Content-Length': buffer.length.toString()
      }
    });

  } catch (error) {
    console.error('PDF export error:', error);

    return NextResponse.json(
      { success: false, error: 'Export failed' },
      { status: 500 }
    );
  }
}
