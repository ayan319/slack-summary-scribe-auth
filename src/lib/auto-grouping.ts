/**
 * Auto-Bookmark & Grouping System
 * Intelligent summary categorization and tagging using AI
 */

export interface SummaryTag {
  id: string;
  name: string;
  color: string;
  category: 'topic' | 'team' | 'priority' | 'project' | 'type' | 'custom';
  confidence: number;
  autoGenerated: boolean;
  usageCount: number;
}

export interface SummaryGroup {
  id: string;
  name: string;
  description: string;
  tags: string[];
  summaryIds: string[];
  category: 'meeting' | 'project' | 'team' | 'client' | 'personal' | 'other';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  createdAt: string;
  updatedAt: string;
  autoGenerated: boolean;
  rules?: GroupingRule[];
}

export interface GroupingRule {
  id: string;
  name: string;
  conditions: {
    keywords?: string[];
    participants?: string[];
    timeframe?: string;
    contentPatterns?: string[];
  };
  actions: {
    addTags?: string[];
    assignToGroup?: string;
    setPriority?: string;
  };
  isActive: boolean;
}

export interface ClassificationResult {
  category: string;
  confidence: number;
  tags: SummaryTag[];
  suggestedGroups: string[];
  priority: string;
  reasoning: string;
}

export class AutoGroupingEngine {
  private static readonly PREDEFINED_TAGS: Partial<SummaryTag>[] = [
    // Topic tags
    { name: 'Planning', color: '#3B82F6', category: 'topic' },
    { name: 'Review', color: '#10B981', category: 'topic' },
    { name: 'Brainstorming', color: '#F59E0B', category: 'topic' },
    { name: 'Decision', color: '#EF4444', category: 'topic' },
    { name: 'Update', color: '#8B5CF6', category: 'topic' },
    { name: 'Training', color: '#06B6D4', category: 'topic' },
    
    // Team tags
    { name: 'Engineering', color: '#1F2937', category: 'team' },
    { name: 'Product', color: '#7C3AED', category: 'team' },
    { name: 'Marketing', color: '#DC2626', category: 'team' },
    { name: 'Sales', color: '#059669', category: 'team' },
    { name: 'Design', color: '#DB2777', category: 'team' },
    { name: 'Leadership', color: '#B45309', category: 'team' },
    
    // Priority tags
    { name: 'Urgent', color: '#DC2626', category: 'priority' },
    { name: 'High Priority', color: '#EA580C', category: 'priority' },
    { name: 'Follow-up Required', color: '#D97706', category: 'priority' },
    { name: 'Action Items', color: '#7C2D12', category: 'priority' },
    
    // Type tags
    { name: 'Standup', color: '#374151', category: 'type' },
    { name: 'Retrospective', color: '#4B5563', category: 'type' },
    { name: 'One-on-One', color: '#6B7280', category: 'type' },
    { name: 'All-Hands', color: '#9CA3AF', category: 'type' },
    { name: 'Client Meeting', color: '#1F2937', category: 'type' }
  ];

  /**
   * Classify and tag a summary using AI
   */
  static async classifySummary(content: string, metadata: {
    participants?: string[];
    title?: string;
    date?: string;
    duration?: number;
  }): Promise<ClassificationResult> {
    try {
      // Use AI to analyze content and extract insights
      const analysis = await this.analyzeContent(content, metadata);
      
      // Generate tags based on analysis
      const tags = await this.generateTags(analysis, content);
      
      // Determine category and priority
      const category = this.determineCategory(analysis, metadata);
      const priority = this.determinePriority(analysis, content);
      
      // Find suggested groups
      const suggestedGroups = await this.findSuggestedGroups(analysis, tags);
      
      return {
        category,
        confidence: analysis.confidence,
        tags,
        suggestedGroups,
        priority,
        reasoning: analysis.reasoning
      };
    } catch (error) {
      console.error('Error classifying summary:', error);
      return {
        category: 'other',
        confidence: 0,
        tags: [],
        suggestedGroups: [],
        priority: 'medium',
        reasoning: 'Classification failed'
      };
    }
  }

  /**
   * Auto-group summaries based on similarity and patterns
   */
  static async autoGroupSummaries(summaryIds: string[], userId: string): Promise<SummaryGroup[]> {
    try {
      // Get summary contents and metadata
      const summaries = await this.getSummariesData(summaryIds);
      
      // Analyze patterns and similarities
      const clusters = await this.clusterSummaries(summaries);
      
      // Create groups from clusters
      const groups: SummaryGroup[] = [];
      
      for (const cluster of clusters) {
        const group = await this.createGroupFromCluster(cluster, userId);
        groups.push(group);
      }
      
      return groups;
    } catch (error) {
      console.error('Error auto-grouping summaries:', error);
      return [];
    }
  }

  /**
   * Apply grouping rules to a summary
   */
  static async applyGroupingRules(summaryId: string, content: string, metadata: any): Promise<{
    tags: string[];
    groups: string[];
    priority?: string;
  }> {
    try {
      const rules = await this.getActiveGroupingRules();
      const results: { tags: string[]; groups: string[]; priority?: string } = { tags: [], groups: [], priority: undefined };
      
      for (const rule of rules) {
        if (await this.evaluateRule(rule, content, metadata)) {
          // Apply rule actions
          if (rule.actions.addTags) {
            results.tags.push(...rule.actions.addTags);
          }
          
          if (rule.actions.assignToGroup) {
            results.groups.push(rule.actions.assignToGroup);
          }
          
          if (rule.actions.setPriority) {
            results.priority = rule.actions.setPriority;
          }
        }
      }
      
      return results;
    } catch (error) {
      console.error('Error applying grouping rules:', error);
      return { tags: [], groups: [] };
    }
  }

  /**
   * Get smart tag suggestions based on content
   */
  static async getTagSuggestions(content: string, existingTags: string[] = []): Promise<SummaryTag[]> {
    try {
      // Analyze content for tag suggestions
      const analysis = await this.analyzeForTags(content);
      
      // Filter out existing tags
      const suggestions = analysis.suggestedTags.filter((tag: any) =>
        !existingTags.includes(tag.name)
      );
      
      // Add predefined tags that match
      const predefinedMatches = this.PREDEFINED_TAGS.filter(tag => 
        this.matchesPredefinedTag(tag, content) && 
        !existingTags.includes(tag.name!)
      );
      
      return [...suggestions, ...predefinedMatches.map(tag => ({
        ...tag,
        id: `tag_${Date.now()}_${Math.random().toString(36).substring(2)}`,
        confidence: 0.8,
        autoGenerated: true,
        usageCount: 0
      } as SummaryTag))];
    } catch (error) {
      console.error('Error getting tag suggestions:', error);
      return [];
    }
  }

  /**
   * Create smart bookmark based on usage patterns
   */
  static async createSmartBookmark(summaryId: string, userId: string): Promise<{
    shouldBookmark: boolean;
    reason: string;
    suggestedTags: string[];
  }> {
    try {
      // Analyze user's bookmarking patterns
      const patterns = await this.analyzeBookmarkingPatterns(userId);
      
      // Get summary data
      const summary = await this.getSummaryData(summaryId);
      
      // Determine if this should be bookmarked
      const shouldBookmark = this.shouldAutoBookmark(summary, patterns);
      
      return {
        shouldBookmark,
        reason: shouldBookmark 
          ? 'This summary matches your important content patterns'
          : 'This summary doesn\'t match your typical bookmark criteria',
        suggestedTags: shouldBookmark ? patterns.commonTags : []
      };
    } catch (error) {
      console.error('Error creating smart bookmark:', error);
      return {
        shouldBookmark: false,
        reason: 'Unable to analyze bookmark patterns',
        suggestedTags: []
      };
    }
  }

  // Private helper methods
  private static async analyzeContent(content: string, metadata: any): Promise<any> {
    // Use AI to analyze content
    const prompt = `Analyze this meeting summary and extract key insights:

Content: ${content}
Participants: ${metadata.participants?.join(', ') || 'Unknown'}
Title: ${metadata.title || 'Untitled'}

Extract:
1. Main topics discussed
2. Meeting type (standup, planning, review, etc.)
3. Key decisions made
4. Action items identified
5. Urgency level
6. Team/department involved

Provide confidence score (0-1) and reasoning.`;

    // Mock AI response - in production, call actual AI service
    return {
      topics: ['planning', 'product roadmap', 'Q4 goals'],
      meetingType: 'planning',
      decisions: ['Launch feature X in Q4', 'Hire 2 engineers'],
      actionItems: ['Create technical spec', 'Schedule interviews'],
      urgency: 'medium',
      team: 'product',
      confidence: 0.85,
      reasoning: 'Clear planning discussion with specific outcomes'
    };
  }

  private static async generateTags(analysis: any, content: string): Promise<SummaryTag[]> {
    const tags: SummaryTag[] = [];
    
    // Generate topic tags
    for (const topic of analysis.topics) {
      tags.push({
        id: `tag_${Date.now()}_${Math.random().toString(36).substring(2)}`,
        name: topic.charAt(0).toUpperCase() + topic.slice(1),
        color: this.getTagColor(topic),
        category: 'topic',
        confidence: 0.8,
        autoGenerated: true,
        usageCount: 0
      });
    }
    
    // Generate team tags
    if (analysis.team) {
      tags.push({
        id: `tag_${Date.now()}_${Math.random().toString(36).substring(2)}`,
        name: analysis.team.charAt(0).toUpperCase() + analysis.team.slice(1),
        color: this.getTagColor(analysis.team),
        category: 'team',
        confidence: 0.9,
        autoGenerated: true,
        usageCount: 0
      });
    }
    
    // Generate type tags
    if (analysis.meetingType) {
      tags.push({
        id: `tag_${Date.now()}_${Math.random().toString(36).substring(2)}`,
        name: analysis.meetingType.charAt(0).toUpperCase() + analysis.meetingType.slice(1),
        color: this.getTagColor(analysis.meetingType),
        category: 'type',
        confidence: 0.85,
        autoGenerated: true,
        usageCount: 0
      });
    }
    
    return tags;
  }

  private static determineCategory(analysis: any, metadata: any): string {
    if (analysis.meetingType === 'standup') return 'meeting';
    if (analysis.topics.includes('project')) return 'project';
    if (metadata.participants?.length > 5) return 'team';
    return 'meeting';
  }

  private static determinePriority(analysis: any, content: string): string {
    if (analysis.urgency === 'high' || content.toLowerCase().includes('urgent')) return 'urgent';
    if (analysis.decisions.length > 0 || analysis.actionItems.length > 2) return 'high';
    if (analysis.actionItems.length > 0) return 'medium';
    return 'low';
  }

  private static async findSuggestedGroups(analysis: any, tags: SummaryTag[]): Promise<string[]> {
    // Find existing groups that match the analysis
    const suggestions: string[] = [];
    
    // Mock suggestions based on analysis
    if (analysis.team === 'product') {
      suggestions.push('Product Team Meetings');
    }
    
    if (analysis.meetingType === 'planning') {
      suggestions.push('Planning Sessions');
    }
    
    return suggestions;
  }

  private static async getSummariesData(summaryIds: string[]): Promise<any[]> {
    // Mock data - in production, fetch from database
    return summaryIds.map(id => ({
      id,
      content: 'Mock summary content',
      metadata: {}
    }));
  }

  private static async clusterSummaries(summaries: any[]): Promise<any[]> {
    // Use AI/ML to cluster similar summaries
    return [
      {
        summaries: summaries.slice(0, 2),
        commonThemes: ['planning', 'product'],
        suggestedName: 'Product Planning'
      }
    ];
  }

  private static async createGroupFromCluster(cluster: any, userId: string): Promise<SummaryGroup> {
    return {
      id: `group_${Date.now()}_${Math.random().toString(36).substring(2)}`,
      name: cluster.suggestedName,
      description: `Auto-generated group for ${cluster.commonThemes.join(', ')} discussions`,
      tags: cluster.commonThemes,
      summaryIds: cluster.summaries.map((s: any) => s.id),
      category: 'meeting',
      priority: 'medium',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      autoGenerated: true
    };
  }

  private static async getActiveGroupingRules(): Promise<GroupingRule[]> {
    // Mock rules - in production, fetch from database
    return [
      {
        id: 'rule_1',
        name: 'Product Team Auto-tag',
        conditions: {
          participants: ['product-manager', 'designer'],
          keywords: ['roadmap', 'feature', 'user story']
        },
        actions: {
          addTags: ['Product', 'Planning'],
          assignToGroup: 'Product Team Meetings'
        },
        isActive: true
      }
    ];
  }

  private static async evaluateRule(rule: GroupingRule, content: string, metadata: any): Promise<boolean> {
    // Evaluate if rule conditions are met
    const contentLower = content.toLowerCase();
    
    // Check keywords
    if (rule.conditions.keywords) {
      const hasKeywords = rule.conditions.keywords.some(keyword => 
        contentLower.includes(keyword.toLowerCase())
      );
      if (!hasKeywords) return false;
    }
    
    // Check participants
    if (rule.conditions.participants && metadata.participants) {
      const hasParticipants = rule.conditions.participants.some(participant =>
        metadata.participants.some((p: string) => p.toLowerCase().includes(participant.toLowerCase()))
      );
      if (!hasParticipants) return false;
    }
    
    return true;
  }

  private static async analyzeForTags(content: string): Promise<any> {
    // Analyze content for tag suggestions
    return {
      suggestedTags: [
        {
          name: 'Planning',
          color: '#3B82F6',
          category: 'topic',
          confidence: 0.9
        }
      ]
    };
  }

  private static matchesPredefinedTag(tag: Partial<SummaryTag>, content: string): boolean {
    const contentLower = content.toLowerCase();
    const tagName = tag.name?.toLowerCase() || '';
    
    // Simple keyword matching - in production, use more sophisticated matching
    return contentLower.includes(tagName) || 
           (tagName === 'planning' && contentLower.includes('plan')) ||
           (tagName === 'review' && contentLower.includes('review'));
  }

  private static async analyzeBookmarkingPatterns(userId: string): Promise<any> {
    // Analyze user's bookmarking behavior
    return {
      commonTags: ['Important', 'Follow-up'],
      frequentTopics: ['planning', 'decisions'],
      bookmarkRate: 0.3
    };
  }

  private static async getSummaryData(summaryId: string): Promise<any> {
    // Mock data - in production, fetch from database
    return {
      id: summaryId,
      content: 'Mock summary content',
      metadata: {}
    };
  }

  private static shouldAutoBookmark(summary: any, patterns: any): boolean {
    // Determine if summary should be auto-bookmarked
    return Math.random() > 0.7; // Mock logic
  }

  private static getTagColor(name: string): string {
    // Generate consistent colors for tags
    const colors = [
      '#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6',
      '#06B6D4', '#84CC16', '#F97316', '#EC4899', '#6366F1'
    ];
    
    let hash = 0;
    for (let i = 0; i < name.length; i++) {
      hash = name.charCodeAt(i) + ((hash << 5) - hash);
    }
    
    return colors[Math.abs(hash) % colors.length];
  }
}
